import turtle
import time
import random

wn = turtle.Screen()
wn.title("Violka TD")
wn.bgcolor("black")
wn.setup(width=900, height=700)
wn.tracer(0)

# ==========================================
# PATH DRAWING
# ==========================================
path_drawer = turtle.Turtle()
path_drawer.hideturtle()
path_drawer.speed(0)
path_drawer.color("gray")
path_drawer.pensize(20)

waypoints = [
    (-350, 0),
    (-100, 0),
    (-100, 150),
    (150, 150),
    (150, -100),
    (350, -100),
]

path_drawer.penup()
path_drawer.goto(waypoints[0])
path_drawer.pendown()
for wp in waypoints[1:]:
    path_drawer.goto(wp)

# ==========================================
# UI PANEL (Right Sidebar)
# ==========================================
sidebar = turtle.Turtle()
sidebar.hideturtle()
#sidebar.penup()
#sidebar.goto(280, 350)
#sidebar.pendown()
#sidebar.goto(280, -350)
#sidebar.goto(400, -350)
#sidebar.goto(400, 350)
#sidebar.goto(280, 350)
#sidebar.end_fill()

sidebar.penup()
sidebar.goto(340, 300)
sidebar.color("white")
sidebar.write("TOWERS", align="center", font=("Arial", 18, "bold"))

# ==========================================
# MONEY & LIVES
# ==========================================
money_value = 2000
money_text = turtle.Turtle()
money_text.hideturtle()
money_text.penup()
money_text.goto(-350, -300)
money_text.color("white")

def update_money_display():
    money_text.clear()
    money_text.write(f"Money: {money_value}", font=("Arial", 18, "bold"))

update_money_display()

lives = 20
lives_text = turtle.Turtle()
lives_text.hideturtle()
lives_text.penup()
lives_text.goto(-50, -300)
lives_text.color("white")

def update_lives_display():
    lives_text.clear()
    lives_text.write(f"Lives: {lives}", font=("Arial", 18, "bold"))

update_lives_display()

# ==========================================
# GAME VARIABLES
# ==========================================
towers = []
enemies = []
placing_mode = False
ghost_tower = None
tower_cost = 100
tower_range_circle = None
selected_tower_type = None

# ==========================================
# TOWER TYPES
# ==========================================
tower_types = {
    "Sniper": {"damage":40, "range":300, "speed":1.5, "color":"purple", "cost":150},
    "Splash": {"damage":10, "range":120, "speed":1.0, "color":"orange", "cost":140},
    "Fast": {"damage":10, "range":170, "speed":0.5, "color":"blue", "cost":100},
}

# ==========================================
# TOWER BUTTONS
# ==========================================
tower_buttons = []

button_y = 200
for t_type, props in tower_types.items():
    
    cost = turtle.Turtle()
    cost.color("white")
    cost.penup()
    cost.goto(325, button_y+20)
    cost.write(props["cost"], font=("Arial", 14, "bold"),)
    cost.hideturtle()
    
    
    
    
    btn = turtle.Turtle()
    btn.shape("square")
    btn.color(props["color"])
    btn.shapesize(stretch_wid=2, stretch_len=2)
    btn.penup()
    btn.goto(340, button_y)
    #btn.write(props["cost"], font=("Arial", 14, "bold"))

    button_y -= 80
    
    

def select_tower(x, y):
    global placing_mode, ghost_tower, selected_tower_type
    for btn, t_type in tower_buttons:
        if btn.distance(x, y) < 30:
            props = tower_types[t_type]
            if money_value < props["cost"]:
                print("Not enough money for", t_type)
                return
            selected_tower_type = t_type
            placing_mode = True
            ghost_tower = turtle.Turtle()
            ghost_tower.shape("circle")
            ghost_tower.color("yellow")
            ghost_tower.shapesize(1.5)
            ghost_tower.penup()
            # Range circle
            global tower_range_circle
            tower_range_circle = turtle.Turtle()
            tower_range_circle.hideturtle()
            tower_range_circle.penup()
            tower_range_circle.pensize(2)
            tower_range_circle.color("white")

            # draw range circle correctly
            tower_range_circle.goto(btn.xcor(), btn.ycor() - props["range"])
            tower_range_circle.pendown()
            tower_range_circle.circle(props["range"])
            tower_range_circle.penup()

for btn, _ in tower_buttons:
    btn.onclick(select_tower)

# ==========================================
# FOLLOW MOUSE
# ==========================================
def follow_mouse(x, y):
    global ghost_tower, tower_range_circle, selected_tower_type

    if placing_mode and ghost_tower:
        ghost_tower.goto(x, y)

        # update range circle position
        if tower_range_circle:
            r = tower_types[selected_tower_type]["range"]
            tower_range_circle.clear()
            tower_range_circle.goto(x, y - r)
            tower_range_circle.pendown()
            tower_range_circle.circle(r)
            tower_range_circle.penup()

wn.onscreenclick(follow_mouse, 1)

# ==========================================
# PLACE TOWER
# ==========================================
def place_tower(x, y):
    global placing_mode, money_value, ghost_tower, tower_range_circle, selected_tower_type
    if not placing_mode or selected_tower_type is None:
        return
    if x > 280:  # sidebar
        return

    props = tower_types[selected_tower_type]
    towers.append(
        Tower(x, y, props["damage"], props["range"], props["speed"], props["color"])
    )
    money_value -= props["cost"]
    update_money_display()

    ghost_tower.hideturtle()
    ghost_tower = None
    if tower_range_circle:
        tower_range_circle.hideturtle()
        tower_range_circle = None
    placing_mode = False
    selected_tower_type = None

wn.onclick(place_tower, btn=1)

# ==========================================
# CANCEL PLACEMENT (Right Click)
# ==========================================
def cancel_placement(x, y):
    global placing_mode, ghost_tower, tower_range_circle, selected_tower_type
    if placing_mode:
        if ghost_tower:
            ghost_tower.hideturtle()
        if tower_range_circle:
            tower_range_circle.hideturtle()
        placing_mode = False
        selected_tower_type = None

wn.onclick(cancel_placement, btn=3)

# ==========================================
# TOWER CLASS
# ==========================================
class Tower:
    def __init__(self, x, y, damage, range_, speed, color="blue"):
        self.x = x
        self.y = y
        self.damage = damage
        self.range = range_
        self.speed = speed
        self.cooldown = 0

        self.t = turtle.Turtle()
        self.t.shape("square")
        self.t.color(color)
        self.t.penup()
        self.t.goto(self.x, self.y)

        # Range circle visible on click
        self.range_circle = turtle.Turtle()
        self.range_circle.hideturtle()
        self.range_circle.penup()
        self.range_circle.pensize(2)
        self.range_circle.color("white")
        self.range_circle.goto(self.x, self.y)

    def update(self, dt, enemies):
        if self.cooldown > 0:
            self.cooldown -= dt
        for enemy in enemies:
            dist = ((enemy.x - self.x)**2 + (enemy.y - self.y)**2)**0.5
            if dist <= self.range and self.cooldown <= 0:
                enemy.health -= self.damage
                self.cooldown = self.speed
                break

# ==========================================
# ENEMY CLASS
# ==========================================
class Enemy:
    def __init__(self, x, y, type="Fast"):
        self.x = x
        self.y = y
        self.path_index = 0
        self.type = type

        # Define enemy type
        if type=="Fast":
            self.health = 50
            self.speed = 120
            self.t = turtle.Turtle()
            self.t.color("yellow")
        elif type=="Tank":
            self.health = 300
            self.speed = 40
            self.t = turtle.Turtle()
            self.t.color("darkred")
        elif type=="Boss":
            self.health = 1500
            self.speed = 50
            self.t = turtle.Turtle()
            self.t.shapesize(2)
            self.t.color("magenta")
        else:
            self.health = 100
            self.speed = 60
            self.t = turtle.Turtle()
            self.t.color("red")

        self.t.shape("circle")
        self.t.penup()
        self.t.goto(self.x, self.y)

    def move(self, dt):
        global lives
        if self.path_index >= len(waypoints)-1:
            self.t.hideturtle()
            lives -= 1
            update_lives_display()
            return "escaped"

        target_x, target_y = waypoints[self.path_index+1]
        dx = target_x - self.x
        dy = target_y - self.y
        dist = (dx**2 + dy**2)**0.5
        if dist==0: return
        step = self.speed*dt
        self.x += dx/dist*step
        self.y += dy/dist*step
        self.t.goto(self.x, self.y)
        if dist < step:
            self.path_index += 1
        return "alive"

    def is_dead(self):
        if self.health <= 0:
            self.t.hideturtle()
            return True
        return False

# ==========================================
# WAVE SYSTEM
# ==========================================
wave_number = 1
time_since_last_spawn = 0
spawn_delay = 1.0
enemies_to_spawn = 3
enemy_types_cycle = ["Fast","Tank","Boss"]

wave_text = turtle.Turtle()
wave_text.hideturtle()
wave_text.penup()
wave_text.color("white")
wave_text.goto(150, -300)

def update_wave_display():
    wave_text.clear()
    wave_text.write(f"Wave: {wave_number}", font=("Arial", 18, "bold"))
update_wave_display()

# ==========================================
# MAIN LOOP
# ==========================================
last_time = time.time()

while True:
    if lives <= 0:
        print("GAME OVER!")
        break

    now = time.time()
    dt = now - last_time
    last_time = now

    # SPAWN ENEMIES
    time_since_last_spawn += dt
    if enemies_to_spawn > 0 and time_since_last_spawn >= spawn_delay:
        e_type = enemy_types_cycle[(wave_number-1) % len(enemy_types_cycle)]
        enemies.append(Enemy(waypoints[0][0], waypoints[0][1], e_type))
        enemies_to_spawn -= 1
        time_since_last_spawn = 0

    # NEXT WAVE
    if enemies_to_spawn == 0 and len(enemies) == 0:
        wave_number += 1
        enemies_to_spawn = 3 + wave_number*2
        print(f"--- WAVE {wave_number} ---")
        update_wave_display()
        
    # MOVE ENEMIES
    new_enemy_list = []
    for e in enemies:
        status = e.move(dt)
        if status != "escaped":
            new_enemy_list.append(e)
    enemies = new_enemy_list

    # UPDATE TOWERS
    for t in towers:
        t.update(dt, enemies)

    # REMOVE DEAD ENEMIES AND GIVE MONEY
    alive = []
    for e in enemies:
        if e.is_dead():
            money_value += 30
            update_money_display()
        else:
            alive.append(e)
    enemies = alive

    wn.update()
    
